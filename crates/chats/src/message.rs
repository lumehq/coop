use chrono::{Local, TimeZone};
use gpui::SharedString;
use nostr_sdk::prelude::*;

/// # Message
///
/// Represents a message in the application.
///
/// ## Fields
///
/// - `id`: The unique identifier for the message
/// - `content`: The text content of the message
/// - `author`: Profile information about who created the message
/// - `mentions`: List of profiles mentioned in the message
/// - `created_at`: Timestamp when the message was created
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Message {
    pub id: EventId,
    pub content: String,
    pub author: Profile,
    pub mentions: Vec<Profile>,
    pub created_at: Timestamp,
}

impl Message {
    /// Creates a new message with the provided details
    ///
    /// # Arguments
    ///
    /// * `id` - Unique event identifier
    /// * `content` - Message text content
    /// * `author` - Profile of the message author
    /// * `created_at` - When the message was created
    ///
    /// # Returns
    ///
    /// A new `Message` instance
    pub fn new(id: EventId, content: String, author: Profile, created_at: Timestamp) -> Self {
        Self {
            id,
            content,
            author,
            created_at,
            mentions: vec![],
        }
    }

    /// Adds or replaces mentions in the message
    ///
    /// # Arguments
    ///
    /// * `mentions` - New list of mentioned profiles
    ///
    /// # Returns
    ///
    /// The same message with updated mentions
    pub fn with_mentions(mut self, mentions: impl IntoIterator<Item = Profile>) -> Self {
        self.mentions.extend(mentions);
        self
    }

    /// Formats the message timestamp as a human-readable relative time
    ///
    /// # Returns
    ///
    /// A formatted string like "Today at 12:30 PM", "Yesterday at 3:45 PM",
    /// or a date and time for older messages
    pub fn ago(&self) -> SharedString {
        let input_time = match Local.timestamp_opt(self.created_at.as_u64() as i64, 0) {
            chrono::LocalResult::Single(time) => time,
            _ => return "Invalid timestamp".into(),
        };

        let now = Local::now();
        let input_date = input_time.date_naive();
        let now_date = now.date_naive();
        let yesterday_date = (now - chrono::Duration::days(1)).date_naive();

        let time_format = input_time.format("%H:%M %p");

        match input_date {
            date if date == now_date => format!("Today at {time_format}"),
            date if date == yesterday_date => format!("Yesterday at {time_format}"),
            _ => format!("{}, {time_format}", input_time.format("%d/%m/%y")),
        }
        .into()
    }
}

/// # RoomMessage
///
/// Represents different types of messages that can appear in a room.
///
/// ## Variants
///
/// - `User`: A message sent by a user
/// - `System`: A message generated by the system
/// - `Announcement`: A special message type used for room announcements
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum RoomMessage {
    /// User message
    User(Box<Message>),
    /// System message
    System(SharedString),
    /// Only use for UI purposes.
    /// Placeholder will be used for display room announcement
    Announcement,
}

impl RoomMessage {
    /// Creates a new user message
    ///
    /// # Arguments
    ///
    /// * `message` - The message content
    ///
    /// # Returns
    ///
    /// A `RoomMessage::User` variant
    pub fn user(message: Message) -> Self {
        Self::User(Box::new(message))
    }

    /// Creates a new system message
    ///
    /// # Arguments
    ///
    /// * `content` - The system message content
    ///
    /// # Returns
    ///
    /// A `RoomMessage::System` variant
    pub fn system(content: SharedString) -> Self {
        Self::System(content)
    }

    /// Creates a new announcement placeholder
    ///
    /// # Returns
    ///
    /// A `RoomMessage::Announcement` variant
    pub fn announcement() -> Self {
        Self::Announcement
    }
}
